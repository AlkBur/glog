package glog

import (
	"runtime"
	"strconv"
	"strings"
)

type StackTraceElement struct {
	class  string
	method string
	file   string
	line   int
}

func getStackTrace() []*StackTraceElement {
	arr := make([]*StackTraceElement, 0)

	pc := uintptr(0)
	file := ""
	line := 0
	ok := false
	name := ""

	//callers := []string{}
	for i := 0; ; i++ {
		pc, file, line, ok = runtime.Caller(i)
		if !ok {
			// The breaks below failed to terminate the loop, and we ran off the
			// end of the call stack.
			break
		}

		// This is a huge edge case, but it will panic if this is the case, see #180
		if file == "<autogenerated>" {
			break
		}

		f := runtime.FuncForPC(pc)
		if f == nil {
			break
		}
		name = f.Name()

		// testing.tRunner is the standard library function that calls
		// tests. Subtests are called directly by tRunner, without going through
		// the Test/Benchmark/Example function that contains the t.Run calls, so
		// with subtests we should break when we hit tRunner, without adding it
		// to the list of callers.
		if name == "runtime.goexit" {
			break
		} else if name == "testing.tRunner" {
			break
		}

		lastSlash := strings.LastIndex(name, "/")
		if lastSlash < 0 {
			lastSlash = 0
		} else {
			lastSlash++
		}
		lastDot := strings.LastIndex(name, ".")
		if lastDot < 0 {
			lastDot = 0
		}

		el := &StackTraceElement{
			file:   file,
			method: name[lastDot+1:],
			class:  name[lastSlash:lastDot],
			line:   line,
		}
		arr = append(arr, el)
	}
	//return strings.Join(callers, "\n\r\t\t\t")

	return arr
}

func (s *StackTraceElement) getClassName() string {
	return s.class
}

func (s *StackTraceElement) getMethodName() string {
	return s.method
}

func (s *StackTraceElement) getFileName() string {
	return s.file
}

func (s *StackTraceElement) getLineNumber() string {
	return strconv.Itoa(s.line)
}
